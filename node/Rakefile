require 'bundler/setup'

Bundler.require(:default)

require "json"
require "tempfile"
require "yaml"
require "zlib"

# fog documentation: http://fog.io/latest/compute/
# yaml documentation: http://yaml.org/

# Yeah yeah yeah, we shouldn't hard code this stuff. I put ripped so much of
# this from when I was automating my personal deployment, that a lot is hard
# coded into constants here.
INIT_TIME    = Time.now
USERNAME     = "nat"
USERS        = [USERNAME]
NAME         = "billow-in-#{INIT_TIME.to_i}" # GCE Doesn't allow dots
REGION       = "europe-west1"
ZONE         = "#{REGION}-b"
IP           = nil
MACHINE_TYPE = "n1-standard-1"
GITHUB_PAT   = ENV['GITHUB_ACCESS_TOKEN']
PRIVATE_KEY  = File.expand_path("~/Dropbox/Keys/gce_key")
PUBLIC_KEY   = File.expand_path("~/Dropbox/Keys/gce_key.pub")
DISK_SIZE    = 10 # Image is 10 GB, so you're 10 GB.
DISK2_SIZE   = 200

def compute_connection
  Fog::Compute.new({
    :provider                         => "Google",
    :google_client_email              => "940380154622@developer.gserviceaccount.com",
    :google_key_location              => "~/Projects/icco.me/etc/keys/icco-cloud.p12",
    :google_project                   => "icco-cloud",
  })
end

def ssh_and_run commands
  server = compute_connection.servers.get(NAME)

  # I gotta set these to SSH
  server.username = USERNAME
  server.private_key_path = PRIVATE_KEY
  server.public_key_path  = PUBLIC_KEY

  # Run and print out results
  commands.each do |cmd|
    puts cmd
    result = server.ssh(cmd)
    puts
    result.each {|r| puts r.stdout }
  end

  return true
end

def scp_upload from, to
  server = compute_connection.servers.get(NAME)

  # I gotta set these to SSH
  server.username = USERNAME
  server.private_key_path = "~/.ssh/google_compute_engine"
  server.public_key_path  = "~/.ssh/google_compute_engine.pub"

  return server.scp_upload(File.expand_path(from), File.expand_path(to))
end

def startup_script package_file_name, user_list
  commands = []

  commands.push "apt-get update"
  commands.push "apt-get -y install aptitude vim git make curl software-properties-common dnsutils"
  commands.push "sed -i 's/^# d/d/g' /etc/apt/sources.list"
  commands.push "aptitude update && sudo DEBIAN_FRONTEND=noninteractive aptitude -y upgrade"
  commands.push "DEBIAN_FRONTEND=noninteractive aptitude -y install #{File.readlines(package_file_name).map {|l| l.strip }.join ' '}"
  #commands.push "echo '#{hostname}' > /etc/hostname && invoke-rc.d hostname.sh start"
  commands.push "sysctl --system"
  commands.push "echo ';' | sfdisk /dev/sdb"
  commands.push "parted -s /dev/sdb rm 1"
  commands.push "parted -s /dev/sdb mkpart primary 0% 100%"
  commands.push "mkfs.ext4 /dev/sdb1"
  commands.push "curl https://go.googlecode.com/files/go1.5.1.linux-amd64.tar.gz > /tmp/go1.5.1.linux-amd64.tar.gz"
  commands.push "tar -C /usr/local -xzf /tmp/go1.5.1.linux-amd64.tar.gz"
  commands.push "su #{USERNAME} -c 'gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3'"
  commands.push "su #{USERNAME} -c '\\curl -sSL https://get.rvm.io | bash -s stable --ruby'"
  commands.push "echo 'DONE!' > /tmp/done.txt"

    return <<-EOF
#!/bin/bash
#{commands.join("\n")}
EOF
end

def boot_server post_boot_scripts = []

  puts "--- Creating Disks (#{Time.now})"
  disk = compute_connection.disks.create({
    :name => "#{NAME}-disk-boot",
    :size_gb => DISK_SIZE,
    :zone_name => ZONE,
    :source_image => 'container-vm-v20150715',
  })
  disk2 = compute_connection.disks.create({
    :name => "#{NAME}-disk-200",
    :size_gb => DISK2_SIZE,
    :zone_name => ZONE,
  })

  disk.wait_for { disk.ready? }
  disk2.wait_for { disk.ready? }

  script = startup_script('packages.txt', USERS).to_s

  attributes = {
    :name => NAME,
    :username => USERNAME,
    :private_key_path => PRIVATE_KEY,
    :public_key_path  => PUBLIC_KEY,
    :disks => [ disk.get_as_boot_disk(true), disk2 ],
    :machine_type => MACHINE_TYPE,
    :zone_name => ZONE,
    :metadata => {
      # https://developers.google.com/compute/docs/howtos/startupscript#example
      'startup-script' => script,
    },
    auto_restart: true
  }

  puts "--- Booting Server (#{Time.now})"
  server = compute_connection.servers.bootstrap(attributes)

  commands = [
    "mkdir -p ~/Projects",
    "mkdir -p ~/Sites",
    "mkdir -p ~/tmp",
    "mkdir -p ~/go_path",
  ]
  ssh_and_run commands

  if IP.nil?
    ip = server.network_interfaces.first["accessConfigs"].first["natIP"]
  else
    ip = IP
  end

  puts "--- Delete local known_hosts for #{ip} (#{Time.now})"
  Kernel.system "ssh-keygen -R #{ip}"

  puts "--- Add SSH Key to Github (#{Time.now})"
  k = SSHKey.generate

  pub_file = Tempfile.new('icco_key')
  pub_file.write(k.ssh_public_key)
  pub_file.close
  server.scp_upload(pub_file.path, "/home/#{USERNAME}/.ssh/id_rsa.pub")

  pri_file = Tempfile.new('icco_key')
  pri_file.write(k.private_key)
  pri_file.close
  server.scp_upload(pri_file.path, "/home/#{USERNAME}/.ssh/id_rsa")

  data = { :title => "#{NAME}-#{INIT_TIME.strftime('%Y.%m.%d.%H.%M')}", :key => k.ssh_public_key }.to_json
  commands = [
    "curl -X POST -d '#{data}' -u #{GITHUB_PAT}:x-oauth-basic https://api.github.com/user/keys -H \"Content-Type: application/json\""
  ]
  ssh_and_run commands

  puts "--- Installing github keys (#{Time.now})"
  ssh_and_run [ "ssh-keyscan -t rsa,dsa github.com | sort -u > ~/.ssh/known_hosts" ]

  # [#<Fog::SSH::Result:0x007fa0916ee1d0 @command="which git", @stderr="", @stdout="", @status=1>]
  server.wait_for { ssh('which git').first.stdout != '' }

  puts "--- Git found and installed."
  #Rake::Task["sites:clone"].invoke

  puts "--- Wait for setup to finish."
  server.wait_for(Fog.timeout, 60) { ssh('cat /tmp/done.txt').first.status == 0 }

  puts "--- Run startup scripts."
  ssh_and_run post_boot_scripts

  puts "--- Done! (#{Time.now})"
  puts "--- Running at #{ip}"

  return server
end

desc "Creates a new node for running tasks on."
task :new_node do
  boot_server
end


desc "Creates a new server node for managing nodes."
task :new_server do
  boot_server
end
